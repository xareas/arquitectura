"use strict";(self.webpackChunknotification_center=self.webpackChunknotification_center||[]).push([[7378],{3980:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>c,toc:()=>t});var s=n(4848),r=n(8453);const o={sidebar_position:1},a="Principio SOLID",c={id:"principios/solid",title:"Principio SOLID",description:"Los principios SOLID son un conjunto de cinco principios de dise\xf1o de software que fueron introducidos por Robert C. Martin (tambi\xe9n conocido como Uncle Bob) a principios de la d\xe9cada de 2000. Estos principios est\xe1n dise\xf1ados para ayudar a los desarrolladores a crear sistemas de software que sean f\xe1ciles de mantener, escalables y que promuevan la flexibilidad y la reutilizaci\xf3n del c\xf3digo.",source:"@site/docs/principios/solid.md",sourceDirName:"principios",slug:"/principios/solid",permalink:"/arquitectura/docs/principios/solid",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/principios/solid.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Principios Software",permalink:"/arquitectura/docs/category/principios-software"},next:{title:"Principios KISS",permalink:"/arquitectura/docs/principios/kiss"}},d={},t=[{value:"Principios SOLID",id:"principios-solid",level:2}];function l(e){const i={admonition:"admonition",h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.h1,{id:"principio-solid",children:"Principio SOLID"}),"\n",(0,s.jsx)(i.p,{children:"Los principios SOLID son un conjunto de cinco principios de dise\xf1o de software que fueron introducidos por Robert C. Martin (tambi\xe9n conocido como Uncle Bob) a principios de la d\xe9cada de 2000. Estos principios est\xe1n dise\xf1ados para ayudar a los desarrolladores a crear sistemas de software que sean f\xe1ciles de mantener, escalables y que promuevan la flexibilidad y la reutilizaci\xf3n del c\xf3digo."}),"\n",(0,s.jsxs)(i.admonition,{title:"SOLID",type:"tip",children:[(0,s.jsx)(i.p,{children:"SOLID es un acr\xf3nimo que representa cinco principios fundamentales de dise\xf1o de software en el desarrollo orientado a objetos."}),(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"S"})," - Principio de Responsabilidad \xdanica (Single Responsibility Principle, SRP)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"O"})," - Principio de Abierto/Cerrado (Open/Closed Principle, OCP)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"L"})," - Principio de Sustituci\xf3n de Liskov (Liskov Substitution Principle, LSP)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"I"})," - Principio de Segregaci\xf3n de la Interfaz (Interface Segregation Principle, ISP)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"D"})," - Principio de Inversi\xf3n de Dependencias (Dependency Inversion Principle, DIP)"]}),"\n"]})]}),"\n",(0,s.jsx)(i.h2,{id:"principios-solid",children:"Principios SOLID"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"S - Principio de Responsabilidad \xdanica"})," (Single Responsibility Principle, SRP):\r\nEste principio establece que una clase debe tener solo una raz\xf3n para cambiar, es decir, debe tener una sola responsabilidad. En otras palabras, una clase debe tener una \xfanica tarea o funci\xf3n, y no debe estar sobrecargada con m\xfaltiples responsabilidades. Esto ayuda a mantener el c\xf3digo modular, f\xe1cil de entender y modificar."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"O - Principio de Abierto/Cerrado"})," (Open/Closed Principle, OCP):\r\nEste principio establece que las clases deben estar abiertas para la extensi\xf3n pero cerradas para la modificaci\xf3n. En lugar de modificar el c\xf3digo existente, se debe poder extender su funcionalidad mediante la adici\xf3n de nuevas clases u objetos. Esto se logra a trav\xe9s del uso de la herencia, la composici\xf3n y el uso de patrones de dise\xf1o como el patr\xf3n Strategy o el patr\xf3n Decorator."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"L - Principio de Sustituci\xf3n de Liskov"})," (Liskov Substitution Principle, LSP):\r\nEste principio establece que los objetos de una clase derivada deben poder sustituirse por objetos de la clase base sin afectar el comportamiento correcto del programa. En otras palabras, una instancia de una subclase debe poder ser usada en cualquier lugar donde se espera una instancia de la clase base sin causar problemas de funcionamiento. Esto garantiza la coherencia y la interoperabilidad en el c\xf3digo."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"I - Principio de Segregaci\xf3n de la Interfaz"})," (Interface Segregation Principle, ISP):\r\nEste principio establece que los clientes no deben depender de interfaces que no utilicen. En lugar de tener interfaces grandes y monol\xedticas, es mejor tener interfaces peque\xf1as y espec\xedficas que est\xe9n dise\xf1adas para un prop\xf3sito espec\xedfico. Esto evita que las clases dependan de m\xe9todos que no necesitan y promueve la cohesi\xf3n y la flexibilidad en el dise\xf1o."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"D - Principio de Inversi\xf3n de Dependencias"})," (Dependency Inversion Principle, DIP):\r\nEste principio establece que los m\xf3dulos de alto nivel no deben depender de m\xf3dulos de bajo nivel, sino que ambos deben depender de abstracciones. Adem\xe1s, las abstracciones no deben depender de los detalles, sino que los detalles deben depender de las abstracciones. Esto se logra mediante el uso de interfaces o clases abstractas que permiten la creaci\xf3n de componentes intercambiables y que facilitan las pruebas unitarias y la modularidad del c\xf3digo."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>c});var s=n(6540);const r={},o=s.createContext(r);function a(e){const i=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:i},e.children)}}}]);