"use strict";(self.webpackChunknotification_center=self.webpackChunknotification_center||[]).push([[862],{5903:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>t,metadata:()=>r,toc:()=>c});var o=n(4848),a=n(8453);const t={sidebar_position:4},s=".Domain",r={id:"arquitectura/domain",title:".Domain",description:"Capa de Dominio",source:"@site/docs/arquitectura/domain.mdx",sourceDirName:"arquitectura",slug:"/arquitectura/domain",permalink:"/arquitectura/docs/arquitectura/domain",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/arquitectura/domain.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:".Application.Contracts",permalink:"/arquitectura/docs/arquitectura/application-contracts"},next:{title:".Domain.Shared",permalink:"/arquitectura/docs/arquitectura/domain-shared"}},d={},c=[{value:"Capa de Dominio",id:"capa-de-dominio",level:2},{value:"Entity",id:"entity",level:3},{value:"Value Object",id:"value-object",level:3},{value:"Aggregate &amp; Aggregate Root",id:"aggregate--aggregate-root",level:3},{value:"Repository( Interface )",id:"repository-interface-",level:3},{value:"Domain Services",id:"domain-services",level:3},{value:"Specification",id:"specification",level:3},{value:"Domain Event",id:"domain-event",level:3}];function l(e){const i={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.h1,{id:"domain",children:".Domain"}),"\n",(0,o.jsx)(i.h2,{id:"capa-de-dominio",children:"Capa de Dominio"}),"\n",(0,o.jsx)(i.admonition,{title:"Tip",type:"tip",children:(0,o.jsx)(i.p,{children:"En el desarrollo de software, la capa de dominio es crucial para representar las reglas de negocio de manera clara. El patr\xf3n Repositorio es una parte esencial de esta capa, permiti\xe9ndonos separar la l\xf3gica de acceso a datos de la l\xf3gica del dominio. Con interfaces de Repositorio, podemos definir operaciones CRUD para nuestras entidades sin preocuparnos por la fuente de datos."})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Entidades"}),"\n",(0,o.jsx)(i.li,{children:"Value Objects (DTO)"}),"\n",(0,o.jsx)(i.li,{children:"Domain Services (Managers)"}),"\n",(0,o.jsx)(i.li,{children:"Domain Events"}),"\n",(0,o.jsx)(i.li,{children:"Interfaces de Repositorio"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"entity",children:"Entity"}),"\n",(0,o.jsx)(i.p,{children:"Una Entidad es un objeto con sus propias propiedades.(estado, datos) y m\xe9todos que implementa el negocio.\r\nUna entidad es representado por su identificador \xfanico (Id). Dos entidades con diferentes ID se consideran entidades diferentes."}),"\n",(0,o.jsx)(i.h3,{id:"value-object",children:"Value Object"}),"\n",(0,o.jsx)(i.p,{children:"Un objeto de valor es otro tipo de objeto de dominio. Se identifica por sus propiedades en lugar de por una\r\nIdentificaci\xf3n \xfanica. Eso significa dos objetos de valor con las mismas propiedades se consideran el mismo objeto.\r\nLos objetos generalmente se implementan como inmutables y en su mayor\xeda son mucho m\xe1s simples que las Entidades."}),"\n",(0,o.jsx)(i.h3,{id:"aggregate--aggregate-root",children:"Aggregate & Aggregate Root"}),"\n",(0,o.jsx)(i.p,{children:"Agregado y ra\xedz agregada: un agregado es un cl\xfaster de objetos (entidades y objetos de valor) unidos por\r\nun objeto Ra\xedz. La ra\xedz agregada es una tipo espec\xedfico de entidad con algunas responsabilidades adicionales."}),"\n",(0,o.jsx)(i.h3,{id:"repository-interface-",children:"Repository( Interface )"}),"\n",(0,o.jsx)(i.p,{children:"Un repositorio es una colecci\xf3n de acciones es decir una interfaz  que se utiliza en las capas de dominio y la aplicaci\xf3n\r\npara acceder al sistema de persistencia de datos (base de datos). Oculta la complejidad del DBMS. La capa de dominio contiene las interfaces de los repositorios."}),"\n",(0,o.jsx)(i.h3,{id:"domain-services",children:"Domain Services"}),"\n",(0,o.jsx)(i.p,{children:"Un servicio de dominio es un servicio sin estado que implementa las reglas de negocio centrales del dominio. Es\r\n\xfatil para implementar l\xf3gica de dominio que depende de tipo de agregado m\xfaltiple (entidad) o alg\xfan tipo externo\r\nservicios."}),"\n",(0,o.jsx)(i.h3,{id:"specification",children:"Specification"}),"\n",(0,o.jsx)(i.p,{children:"Una especificaci\xf3n se utiliza para definir nombres,filtros reutilizables y combinables para entidades y otros\r\nobjetos de negocio. En c# el uso de predicados es un tipo de especificacion."}),"\n",(0,o.jsx)(i.h3,{id:"domain-event",children:"Domain Event"}),"\n",(0,o.jsx)(i.p,{children:"Un Evento de Dominio es una forma de informar otros servicios de manera d\xe9bilmente acoplada, cuando un\r\nocurre un evento espec\xedfico del dominio. Estos tipos de eventos, van relacionados especificamente a eventos que\r\nnormalmente ocurren dentro del un contexto limitado(Bounded Context,Modulo,Microservicio). Existe otro tipos de eventos\r\nque son los Integration Events, para eventos que estan fuera del modulo o microservicios, o del contexto."}),"\n",(0,o.jsx)(i.admonition,{title:"MAS INFORMACION",type:"info",children:(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.a,{href:"/arquitectura/docs/ddd/services#domain-services",children:"Servicios de Dominio"})}),"\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.a,{href:"/arquitectura/docs/ddd/events",children:"Evento de Dominio"})}),"\n"]})})]})}function u(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>r});var o=n(6540);const a={},t=o.createContext(a);function s(e){const i=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),o.createElement(t.Provider,{value:i},e.children)}}}]);